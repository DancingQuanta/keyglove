<!--
Keyglove API Reference Guide
2014-12-07 by Jeff Rowberg <jeff@rowberg.net>

================================================================================
Keyglove source code is placed under the MIT license
Copyright (c) 2014 Jeff Rowberg

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

================================================================================
-->
<html>
  <head>
    <title>Keyglove API Reference Guide</title>
    <style>

.kgapidoc div, .kgapidoc p, .kgapidoc td, .kgapidoc th, .kgapidoc h1, .kgapidoc h2, .kgapidoc h3, .kgapidoc h4, .kgapidoc h5 {
    font-family: Arial, Helvetica, sans-serif;
}

@media screen
  {
.kgapidoc div, .kgapidoc p, .kgapidoc td, .kgapidoc th {
    font-size: 13px;
}
  }
@media print
  {
.kgapidoc div, .kgapidoc p, .kgapidoc td, .kgapidoc th {
    font-size: 11px;
}
  }

@media screen, print
  {
.kgapidoc h2 {
    page-break-before: always;
}
.kgapidoc h3, .kgapidoc h4, .kgapidoc h5 {
    page-break-before: auto;
}
.kgapidoc h5 {
    margin-bottom: 0.5em;
}
.kgapidoc span.headingtab {
    display: inline-block;
    min-width: 40px;
}
.kgapidoc .breakauto {
    page-break-before: auto;
}

.kgapidoc table {
    border: 1px solid #ccc;
    border-collapse: collapse;
    margin: 0 0 1em;
}

.kgapidoc table th, .kgapidoc table td {
    border: 1px solid #ccc;
    padding: 6px 12px;
    text-align: left;
    vertical-align: top;
}

.kgapidoc table thead td {
    background-color: #FFF;
    border: 1px solid #EEE;
    border-bottom: #CCC;
    color: #DDD;
    font-size: 2.4em;
    font-style: italic;
    font-weight: bold;
    height: 85px;
    overflow: hidden;
    padding: 8px 10px 0;
}
.kgapidoc table thead th.tabletitle {
    background-color: #5e858c;
    border-color: #5e858c #fff;
    font-size: 1.1em;
    font-style: italic;
    font-weight: normal;
    padding: 3px 8px 2px;
    text-align: right;
}
.kgapidoc table.command, .kgapidoc table.response, .kgapidoc table.event {
    min-width: 750px;
}
.kgapidoc table.command thead td {
    text-align: right;
    vertical-align: bottom;
}
.kgapidoc table.response thead td, .kgapidoc table.event thead td {
    text-align: left;
    vertical-align: baseline;
}
.kgapidoc table.command thead td img {
    display: block;
    float: left;
}
.kgapidoc table.response thead td img, .kgapidoc table.event thead td img {
    display: block;
    float: right;
}

.kgapidoc table thead th {
    background-color: #000;
    color: #fff;
}

.kgapidoc table tbody tr.header {
    background-color: #f4f4f4;
}

.kgapidoc table tbody tr.payload td {
    font-weight: bold;
}

.kgapidoc ul {
    margin: 0.5em 0;
}

.kgapidoc pre {
    border: 1px solid #CCC;
    width: 750px;
}
  }

    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/googlecode.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <!-- link rel="stylesheet" href="googlecode.css" />
    <script src="highlight.pack.js"></script> -->
  </head>
  <body class="kgapidoc">
    <script>hljs.initHighlightingOnLoad();</script>
    
<h1 align="center">Keyglove API Reference Guide</h1>
<h4 align="center">2014-12-07</h4>
<h4 align="center"><a href="http://keyglove.net" target="_blank">keyglove.net</a><br /><a href="https://github.com/jrowberg/keyglove" target="_blank">github.com/jrowberg/keyglove</a></h4>

<p style="font-size: 1.2em;">This API Reference Guide describes the complete packet structure of all
currently defined commands, responses, and events that are part of the Keyglove
API binary protocol.</p>
<p>

<p style="font-size: 1.2em;"><strong style="color: #F00;">This protocol is still under active development
and has not been officially locked to a specific structure and definition. This
means that the class/ID values as well as the parameter names, types, and order
for any API method MAY CHANGE AT ANY TIME. Please make very sure that you are
always working with the latest available code and reference material.</strong>
</p>

<h2><span class="headingtab">1</span> Protocol class (ID = 0)</h2><p>Protocol events occur when you try to use the protocol in an invalid way, or when you unintentionally send an incomplete command, invalid data, bad parameters, etc. They alert you to the fact that something has gone wrong.</p><p>There are no commands within this class; it only has events.</p><h3><span class="headingtab">1.1</span> Events</h3><h4><span class="headingtab">1.1.1</span> protocol_error <code style="color: #F00;">[ 80 02 00 01 ... ]</code></h4><p>This event occurs when a problem exists with a command you have sent.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x00</td><td>class</td><td>Event class: "protocol"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Event ID: "error"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><th>uint16_t</th><th>code</th><td>Error code describing what went wrong with the protocol communication<ul><li><em>Enum:</em> <a href="#kg_enum_protocol_error_code">protocol_error_code</a></li></ul></td></tr></tbody></table></div><h5><span class="headingtab">1.1.1.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_protocol_error(sender, args):
    print("kg_evt_protocol_error: { code: %04X }" % (args['code']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_protocol_error += my_kg_evt_protocol_error</code></pre><h3><span class="headingtab">1.2</span> Enumerations</h3><h4><span class="headingtab">1.2.1</span> protocol_error_code</h4><p>Describes the nature of a protocol error that has occurred.</p><table class="enumeration"><thead><tr><th>Value</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>invalid_command</td><td>Command class or ID is unknown</td></tr><tr><td>2</td><td>packet_timeout</td><td>Command packet not completed in time</td></tr><tr><td>3</td><td>bad_length</td><td>Length value not supported, 250 bytes or less</td></tr><tr><td>4</td><td>parameter_length</td><td>Length of supplied parameters does not match with command definition</td></tr><tr><td>5</td><td>parameter_range</td><td>Value of supplied parameter(s) outside of valid range</td></tr><tr><td>6</td><td>not_implemented</td><td>Command known but not implemented in this firmware configuration</td></tr></tbody></table><h2><span class="headingtab">2</span> System class (ID = 1)</h2><p>System commands and events relate to the core device, describing things like system boot and uptime, and verifying proper communication or resetting to an initial state.<h3><span class="headingtab">2.1</span> Commands</h3><h4><span class="headingtab">2.1.1</span> system_ping <code style="color: #F00;">[ C0 00 01 01 ]</code></h4><p>Test communication with Keyglove device and get current uptime.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "ping"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x04</td><td>length</td><td>Fixed-length payload (4)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "ping"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;7</td><td>uint32_t</td><td>uptime</td><td>Number of seconds since last boot/reset</td></tr></thead></table></div><h5><span class="headingtab">2.1.1.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_system_ping()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_system_ping())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_system_ping(), timeout)
print("kg_rsp_system_ping: { uptime: %08X }" % (response['payload']['uptime']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_system_ping(sender, args):
    print("kg_rsp_system_ping: { uptime: %08X }" % (args['uptime']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_system_ping += my_kg_rsp_system_ping</code></pre><h4><span class="headingtab">2.1.2</span> system_reset <code style="color: #F00;">[ C0 01 01 02 ... ]</code></h4><p>Reset Keyglove device.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "reset"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode</td><td>Type of reset to perform<ul><li><em>Enum:</em> <a href="#kg_enum_system_reset_mode">system_reset_mode</a></li></ul></td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "reset"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from 'reset' command</td></tr></thead></table></div><h5><span class="headingtab">2.1.2.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_system_reset(mode)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_system_reset(mode))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_system_reset(mode), timeout)
print("kg_rsp_system_reset: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_system_reset(sender, args):
    print("kg_rsp_system_reset: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_system_reset += my_kg_rsp_system_reset</code></pre><h4><span class="headingtab">2.1.3</span> system_get_info <code style="color: #F00;">[ C0 00 01 03 ]</code></h4><p>Get firmware build info.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Command ID: "get_info"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x0C</td><td>length</td><td>Fixed-length payload (12)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Command ID: "get_info"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>major</td><td>Firmware major version number</td></tr><tr class="payload"><td>6&nbsp;-&nbsp;7</td><td>uint16_t</td><td>minor</td><td>Firmware minor version number</td></tr><tr class="payload"><td>8&nbsp;-&nbsp;9</td><td>uint16_t</td><td>patch</td><td>Firmware patch version number</td></tr><tr class="payload"><td>10&nbsp;-&nbsp;11</td><td>uint16_t</td><td>protocol</td><td>API protocol version number</td></tr><tr class="payload"><td>12&nbsp;-&nbsp;15</td><td>uint32_t</td><td>timestamp</td><td>Build timestamp</td></tr></thead></table></div><h5><span class="headingtab">2.1.3.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_system_get_info()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_system_get_info())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_system_get_info(), timeout)
print("kg_rsp_system_get_info: { major: %04X, minor: %04X, patch: %04X, protocol: %04X," \
        " timestamp: %08X }" % (response['payload']['major'],' \
        ' response['payload']['minor'], response['payload']['patch'], \
        response['payload']['protocol'], response['payload']['timestamp']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_system_get_info(sender, args):
    print("kg_rsp_system_get_info: { major: %04X, minor: %04X, patch: %04X, protocol:" \
            " %04X, timestamp: %08X }" % (args['major'], args['minor'], args['patch'],' \
            ' args['protocol'], args['timestamp']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_system_get_info += my_kg_rsp_system_get_info</code></pre><h4><span class="headingtab">2.1.4</span> system_get_capabilities <code style="color: #F00;">[ C0 01 01 04 ... ]</code></h4><p>Get capabilities designed into this unit.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x04</td><td>id</td><td>Command ID: "get_capabilities"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>category</td><td>Category of capabilities to report (0x00 for all)</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x04</td><td>id</td><td>Command ID: "get_capabilities"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>count</td><td>Number of capability reports to expect</td></tr></thead></table></div><h5><span class="headingtab">2.1.4.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_system_get_capabilities(category)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_system_get_capabilities(category))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_system_get_capabilities(category), \
        timeout)
print("kg_rsp_system_get_capabilities: { count: %04X }" % (response['payload']['count']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_system_get_capabilities(sender, args):
    print("kg_rsp_system_get_capabilities: { count: %04X }" % (args['count']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_system_get_capabilities += my_kg_rsp_system_get_capabilities</code></pre><h4><span class="headingtab">2.1.5</span> system_get_memory <code style="color: #F00;">[ C0 00 01 05 ]</code></h4><p>Get system memory usage.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x05</td><td>id</td><td>Command ID: "get_memory"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x08</td><td>length</td><td>Fixed-length payload (8)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x05</td><td>id</td><td>Command ID: "get_memory"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;7</td><td>uint32_t</td><td>free_ram</td><td>Free bytes of RAM</td></tr><tr class="payload"><td>8&nbsp;-&nbsp;11</td><td>uint32_t</td><td>total_ram</td><td>Total bytes of RAM</td></tr></thead></table></div><h5><span class="headingtab">2.1.5.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_system_get_memory()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_system_get_memory())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_system_get_memory(), timeout)
print("kg_rsp_system_get_memory: { free_ram: %08X, total_ram: %08X }" % \
        (response['payload']['free_ram'], response['payload']['total_ram']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_system_get_memory(sender, args):
    print("kg_rsp_system_get_memory: { free_ram: %08X, total_ram: %08X }" % \
            (args['free_ram'], args['total_ram']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_system_get_memory += my_kg_rsp_system_get_memory</code></pre><h4><span class="headingtab">2.1.6</span> system_get_battery_status <code style="color: #F00;">[ C0 00 01 06 ]</code></h4><p>Get battery status (presence, charge status, charge level)</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x06</td><td>id</td><td>Command ID: "get_battery_status"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x06</td><td>id</td><td>Command ID: "get_battery_status"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>status</td><td>Battery status</td></tr><tr class="payload"><td>5</td><td>uint8_t</td><td>level</td><td>Charge level (0-100)</td></tr></thead></table></div><h5><span class="headingtab">2.1.6.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_system_get_battery_status()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_system_get_battery_status())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_system_get_battery_status(), \
        timeout)
print("kg_rsp_system_get_battery_status: { status: %02X, level: %02X }" % \
        (response['payload']['status'], response['payload']['level']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_system_get_battery_status(sender, args):
    print("kg_rsp_system_get_battery_status: { status: %02X, level: %02X }" % \
            (args['status'], args['level']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_system_get_battery_status += my_kg_rsp_system_get_battery_status</code></pre><h4><span class="headingtab">2.1.7</span> system_set_timer <code style="color: #F00;">[ C0 04 01 07 ... ]</code></h4><p>Set a timer interval to trigger future behavior.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x04</td><td>length</td><td>Fixed-length payload (4)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x07</td><td>id</td><td>Command ID: "set_timer"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>handle</td><td>Timer handle (0-7)</td></tr><tr class="payload"><td>5&nbsp;-&nbsp;6</td><td>uint16_t</td><td>interval</td><td>Interval (10ms units)</td></tr><tr class="payload"><td>7</td><td>uint8_t</td><td>oneshot</td><td>Repeating (0) or one-shot (1)</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Command class: "system"</td></tr><tr class="header"><td>3</td><td>0x07</td><td>id</td><td>Command ID: "set_timer"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from 'set_timer' command</td></tr></thead></table></div><h5><span class="headingtab">2.1.7.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_system_set_timer(handle, interval, oneshot)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_system_set_timer(handle, interval, oneshot))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_system_set_timer(handle, interval, \
        oneshot), timeout)
print("kg_rsp_system_set_timer: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_system_set_timer(sender, args):
    print("kg_rsp_system_set_timer: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_system_set_timer += my_kg_rsp_system_set_timer</code></pre><h3><span class="headingtab">2.2</span> Events</h3><h4><span class="headingtab">2.2.1</span> system_boot <code style="color: #F00;">[ 80 0C 01 01 ... ]</code></h4><p>Indicates that Keyglove has started the boot process.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x0C</td><td>length</td><td>Fixed-length payload (12)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Event class: "system"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Event ID: "boot"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><th>uint16_t</th><th>major</th><td>Firmware major version number</td></tr><tr class="payload"><td>6&nbsp;-&nbsp;7</td><th>uint16_t</th><th>minor</th><td>Firmware minor version number</td></tr><tr class="payload"><td>8&nbsp;-&nbsp;9</td><th>uint16_t</th><th>patch</th><td>Firmware patch version number</td></tr><tr class="payload"><td>10&nbsp;-&nbsp;11</td><th>uint16_t</th><th>protocol</th><td>API protocol version number</td></tr><tr class="payload"><td>12&nbsp;-&nbsp;15</td><th>uint32_t</th><th>timestamp</th><td>Build timestamp</td></tr></tbody></table></div><h5><span class="headingtab">2.2.1.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_system_boot(sender, args):
    print("kg_evt_system_boot: { major: %04X, minor: %04X, patch: %04X, protocol: %04X," \
            " timestamp: %08X }" % (args['major'], args['minor'], args['patch'],' \
            ' args['protocol'], args['timestamp']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_system_boot += my_kg_evt_system_boot</code></pre><h4><span class="headingtab">2.2.2</span> system_ready <code style="color: #F00;">[ 80 00 01 02 ]</code></h4><p>Indicates that Keyglove has completed the boot process and is ready for use.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Event class: "system"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Event ID: "ready"</td></tr></tbody></table></div><h5><span class="headingtab">2.2.2.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_system_ready(sender, args):
    print("kg_evt_system_ready: {  }")
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_system_ready += my_kg_evt_system_ready</code></pre><h4><span class="headingtab">2.2.3</span> system_error <code style="color: #F00;">[ 80 02 01 03 ... ]</code></h4><p>Indicates that Keyglove has encountered an error (RAM, hardware, etc.) that will result in unintended behavior.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Event class: "system"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Event ID: "error"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><th>uint16_t</th><th>code</th><td>Error code describing what went wrong with the system<ul><li><em>Enum:</em> <a href="#kg_enum_system_error_code">system_error_code</a></li></ul></td></tr></tbody></table></div><h5><span class="headingtab">2.2.3.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_system_error(sender, args):
    print("kg_evt_system_error: { code: %04X }" % (args['code']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_system_error += my_kg_evt_system_error</code></pre><h4><span class="headingtab">2.2.4</span> system_capability <code style="color: #F00;">[ 80 03+ 01 04 ... ]</code></h4><p>Provides a record describing specific capabilities designed into this unit.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x03+</td><td>length</td><td>Variable-length payload (3+)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Event class: "system"</td></tr><tr class="header"><td>3</td><td>0x04</td><td>id</td><td>Event ID: "capability"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><th>uint16_t</th><th>category</th><td>Category that this capability report is included in</td></tr><tr class="payload"><td>6</td><th>uint8_t[]</th><th>record</th><td>Capability record(s) in type-length-value format</td></tr></tbody></table></div><h5><span class="headingtab">2.2.4.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_system_capability(sender, args):
    print("kg_evt_system_capability: { category: %04X, record: %s }" % (args['category'], \
            ' '.join(['%02X' % b for b in args['record']])))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_system_capability += my_kg_evt_system_capability</code></pre><h4><span class="headingtab">2.2.5</span> system_battery_status <code style="color: #F00;">[ 80 02 01 05 ... ]</code></h4><p>Indicates that battery status has changed</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Event class: "system"</td></tr><tr class="header"><td>3</td><td>0x05</td><td>id</td><td>Event ID: "battery_status"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>status</th><td>Battery status</td></tr><tr class="payload"><td>5</td><th>uint8_t</th><th>level</th><td>Charge level (0-100)</td></tr></tbody></table></div><h5><span class="headingtab">2.2.5.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_system_battery_status(sender, args):
    print("kg_evt_system_battery_status: { status: %02X, level: %02X }" % (args['status'], \
            args['level']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_system_battery_status += my_kg_evt_system_battery_status</code></pre><h4><span class="headingtab">2.2.6</span> system_timer_tick <code style="color: #F00;">[ 80 06 01 06 ... ]</code></h4><p>Indicates that a previously scheduled software timer has elapsed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x06</td><td>length</td><td>Fixed-length payload (6)</td></tr><tr class="header"><td>2</td><td>0x01</td><td>class</td><td>Event class: "system"</td></tr><tr class="header"><td>3</td><td>0x06</td><td>id</td><td>Event ID: "timer_tick"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>handle</th><td>Timer handle which triggered this event</td></tr><tr class="payload"><td>5&nbsp;-&nbsp;8</td><th>uint32_t</th><th>seconds</th><td>Seconds elapsed since boot</td></tr><tr class="payload"><td>9</td><th>uint8_t</th><th>subticks</th><td>10ms subticks above whole second</td></tr></tbody></table></div><h5><span class="headingtab">2.2.6.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_system_timer_tick(sender, args):
    print("kg_evt_system_timer_tick: { handle: %02X, seconds: %08X, subticks: %02X }" % \
            (args['handle'], args['seconds'], args['subticks']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_system_timer_tick += my_kg_evt_system_timer_tick</code></pre><h3><span class="headingtab">2.3</span> Enumerations</h3><h4><span class="headingtab">2.3.1</span> system_error_code</h4><p>Describes the nature of a system error that has occurred.</p><table class="enumeration"><thead><tr><th>Value</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>out_of_memory</td><td>Could not allocate required memory</td></tr></tbody></table><h4><span class="headingtab">2.3.1</span> system_reset_mode</h4><p>Describes the type of reset to perform.</p><table class="enumeration"><thead><tr><th>Value</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>normal</td><td>Reset Keyglove hardware and all peripherals (Bluetooth, sensors, etc.)</td></tr><tr><td>2</td><td>kgonly</td><td>Reset Keyglove hardware only, no peripherals</td></tr></tbody></table><h2><span class="headingtab">3</span> Touch class (ID = 2)</h2><p>Touch commands and events control and report the behavior of the touch detection interface.</p><h3><span class="headingtab">3.1</span> Commands</h3><h4><span class="headingtab">3.1.1</span> touch_get_mode <code style="color: #F00;">[ C0 00 02 01 ]</code></h4><p>Get the current touch mode.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x02</td><td>class</td><td>Command class: "touch"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "get_mode"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x02</td><td>class</td><td>Command class: "touch"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "get_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode</td><td>Current touch mode setting</td></tr></thead></table></div><h5><span class="headingtab">3.1.1.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_touch_get_mode()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_touch_get_mode())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_touch_get_mode(), timeout)
print("kg_rsp_touch_get_mode: { mode: %02X }" % (response['payload']['mode']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_touch_get_mode(sender, args):
    print("kg_rsp_touch_get_mode: { mode: %02X }" % (args['mode']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_touch_get_mode += my_kg_rsp_touch_get_mode</code></pre><h4><span class="headingtab">3.1.2</span> touch_set_mode <code style="color: #F00;">[ C0 01 02 02 ... ]</code></h4><p>Set a new touch mode.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x02</td><td>class</td><td>Command class: "touch"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "set_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode</td><td>New touch mode to set</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x02</td><td>class</td><td>Command class: "touch"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "set_mode"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from 'set_mode' command</td></tr></thead></table></div><h5><span class="headingtab">3.1.2.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_touch_set_mode(mode)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_touch_set_mode(mode))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_touch_set_mode(mode), timeout)
print("kg_rsp_touch_set_mode: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_touch_set_mode(sender, args):
    print("kg_rsp_touch_set_mode: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_touch_set_mode += my_kg_rsp_touch_set_mode</code></pre><h3><span class="headingtab">3.2</span> Events</h3><h4><span class="headingtab">3.2.1</span> touch_mode <code style="color: #F00;">[ 80 01 02 01 ... ]</code></h4><p>Indicates that the touch mode has changed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x02</td><td>class</td><td>Event class: "touch"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Event ID: "mode"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>mode</th><td>New touch mode</td></tr></tbody></table></div><h5><span class="headingtab">3.2.1.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_touch_mode(sender, args):
    print("kg_evt_touch_mode: { mode: %02X }" % (args['mode']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_touch_mode += my_kg_evt_touch_mode</code></pre><h4><span class="headingtab">3.2.2</span> touch_status <code style="color: #F00;">[ 80 01+ 02 02 ... ]</code></h4><p>Indicates that the touch sensor status has changed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x01+</td><td>length</td><td>Variable-length payload (1+)</td></tr><tr class="header"><td>2</td><td>0x02</td><td>class</td><td>Event class: "touch"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Event ID: "status"</td></tr><tr class="payload"><td>4</td><th>uint8_t[]</th><th>status</th><td>New touch status</td></tr></tbody></table></div><h5><span class="headingtab">3.2.2.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_touch_status(sender, args):
    print("kg_evt_touch_status: { status: %s }" % (' '.join(['%02X' % b for b in \
            args['status']])))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_touch_status += my_kg_evt_touch_status</code></pre><h2><span class="headingtab">4</span> Feedback class (ID = 3)</h2><p>Feedback commands and events control and report on the various types of feedback subsystems, such as a simple LED or more complex devices such as RGB LEDs or piezo buzzers.</p><h3><span class="headingtab">4.1</span> Commands</h3><h4><span class="headingtab">4.1.1</span> feedback_get_blink_mode <code style="color: #F00;">[ C0 00 03 01 ]</code></h4><p>Get current blink feedback mode.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "get_blink_mode"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "get_blink_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode</td><td>Current blink feedback mode</td></tr></thead></table></div><h5><span class="headingtab">4.1.1.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_feedback_get_blink_mode()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_feedback_get_blink_mode())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_feedback_get_blink_mode(), timeout)
print("kg_rsp_feedback_get_blink_mode: { mode: %02X }" % (response['payload']['mode']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_feedback_get_blink_mode(sender, args):
    print("kg_rsp_feedback_get_blink_mode: { mode: %02X }" % (args['mode']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_feedback_get_blink_mode += my_kg_rsp_feedback_get_blink_mode</code></pre><h4><span class="headingtab">4.1.2</span> feedback_set_blink_mode <code style="color: #F00;">[ C0 01 03 02 ... ]</code></h4><p>Set new blink feedback mode.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "set_blink_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode</td><td>New blink feedback mode to set</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "set_blink_mode"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">4.1.2.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_feedback_set_blink_mode(mode)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_feedback_set_blink_mode(mode))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_feedback_set_blink_mode(mode), \
        timeout)
print("kg_rsp_feedback_set_blink_mode: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_feedback_set_blink_mode(sender, args):
    print("kg_rsp_feedback_set_blink_mode: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_feedback_set_blink_mode += my_kg_rsp_feedback_set_blink_mode</code></pre><h4><span class="headingtab">4.1.3</span> feedback_get_piezo_mode <code style="color: #F00;">[ C0 01 03 03 ... ]</code></h4><p>Get current feedback mode for a piezo buzzer.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Command ID: "get_piezo_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>index</td><td>Index of piezo device for which to get the current mode</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x04</td><td>length</td><td>Fixed-length payload (4)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Command ID: "get_piezo_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode</td><td>Current feedback mode for specified piezo device</td></tr><tr class="payload"><td>5</td><td>uint8_t</td><td>duration</td><td>Duration to maintain tone</td></tr><tr class="payload"><td>6&nbsp;-&nbsp;7</td><td>uint16_t</td><td>frequency</td><td>Frequency of tone to generate</td></tr></thead></table></div><h5><span class="headingtab">4.1.3.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_feedback_get_piezo_mode(index)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_feedback_get_piezo_mode(index))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_feedback_get_piezo_mode(index), \
        timeout)
print("kg_rsp_feedback_get_piezo_mode: { mode: %02X, duration: %02X, frequency: %04X }" % \
        (response['payload']['mode'], response['payload']['duration'], \
        response['payload']['frequency']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_feedback_get_piezo_mode(sender, args):
    print("kg_rsp_feedback_get_piezo_mode: { mode: %02X, duration: %02X, frequency: %04X" \
            " }" % (args['mode'], args['duration'], args['frequency']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_feedback_get_piezo_mode += my_kg_rsp_feedback_get_piezo_mode</code></pre><h4><span class="headingtab">4.1.4</span> feedback_set_piezo_mode <code style="color: #F00;">[ C0 05 03 04 ... ]</code></h4><p>Set a new piezo feedback mode for a piezo buzzer.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x05</td><td>length</td><td>Fixed-length payload (5)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x04</td><td>id</td><td>Command ID: "set_piezo_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>index</td><td>Index of piezo device for which to set a new mode</td></tr><tr class="payload"><td>5</td><td>uint8_t</td><td>mode</td><td>New feedback mode to set for specified piezo device</td></tr><tr class="payload"><td>6</td><td>uint8_t</td><td>duration</td><td>Duration to maintain tone</td></tr><tr class="payload"><td>7&nbsp;-&nbsp;8</td><td>uint16_t</td><td>frequency</td><td>Frequency of tone to generate</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x04</td><td>id</td><td>Command ID: "set_piezo_mode"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">4.1.4.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_feedback_set_piezo_mode(index, mode, duration, frequency)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_feedback_set_piezo_mode(index, mode, duration, \
        frequency))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_feedback_set_piezo_mode(index, \
        mode, duration, frequency), timeout)
print("kg_rsp_feedback_set_piezo_mode: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_feedback_set_piezo_mode(sender, args):
    print("kg_rsp_feedback_set_piezo_mode: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_feedback_set_piezo_mode += my_kg_rsp_feedback_set_piezo_mode</code></pre><h4><span class="headingtab">4.1.5</span> feedback_get_vibrate_mode <code style="color: #F00;">[ C0 01 03 05 ... ]</code></h4><p>Get current feedback mode for a vibration motor.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x05</td><td>id</td><td>Command ID: "get_vibrate_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>index</td><td>Index of vibration device for which to get the current mode</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x05</td><td>id</td><td>Command ID: "get_vibrate_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode</td><td>Current feedback mode for specified vibration device</td></tr><tr class="payload"><td>5</td><td>uint8_t</td><td>duration</td><td>Duration to maintain vibration</td></tr></thead></table></div><h5><span class="headingtab">4.1.5.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_feedback_get_vibrate_mode(index)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_feedback_get_vibrate_mode(index))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_feedback_get_vibrate_mode(index), \
        timeout)
print("kg_rsp_feedback_get_vibrate_mode: { mode: %02X, duration: %02X }" % \
        (response['payload']['mode'], response['payload']['duration']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_feedback_get_vibrate_mode(sender, args):
    print("kg_rsp_feedback_get_vibrate_mode: { mode: %02X, duration: %02X }" % \
            (args['mode'], args['duration']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_feedback_get_vibrate_mode += my_kg_rsp_feedback_get_vibrate_mode</code></pre><h4><span class="headingtab">4.1.6</span> feedback_set_vibrate_mode <code style="color: #F00;">[ C0 03 03 06 ... ]</code></h4><p>Set a new vibration motor feedback mode.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x03</td><td>length</td><td>Fixed-length payload (3)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x06</td><td>id</td><td>Command ID: "set_vibrate_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>index</td><td>Index of vibration device for which to set a new mode</td></tr><tr class="payload"><td>5</td><td>uint8_t</td><td>mode</td><td>New feedback mode to set for specified vibration device</td></tr><tr class="payload"><td>6</td><td>uint8_t</td><td>duration</td><td>Duration to maintain vibration</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x06</td><td>id</td><td>Command ID: "set_vibrate_mode"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">4.1.6.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_feedback_set_vibrate_mode(index, mode, duration)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_feedback_set_vibrate_mode(index, mode, duration))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_feedback_set_vibrate_mode(index, \
        mode, duration), timeout)
print("kg_rsp_feedback_set_vibrate_mode: { result: %04X }" % \
        (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_feedback_set_vibrate_mode(sender, args):
    print("kg_rsp_feedback_set_vibrate_mode: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_feedback_set_vibrate_mode += my_kg_rsp_feedback_set_vibrate_mode</code></pre><h4><span class="headingtab">4.1.7</span> feedback_get_rgb_mode <code style="color: #F00;">[ C0 01 03 07 ... ]</code></h4><p>Get current feedback mode for an RGB LED.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x07</td><td>id</td><td>Command ID: "get_rgb_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>index</td><td>Index of RGB device for which to get the current mode</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x03</td><td>length</td><td>Fixed-length payload (3)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x07</td><td>id</td><td>Command ID: "get_rgb_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode_red</td><td>Current feedback mode for specified RGB device red LED</td></tr><tr class="payload"><td>5</td><td>uint8_t</td><td>mode_green</td><td>Current feedback mode for specified RGB device green LED</td></tr><tr class="payload"><td>6</td><td>uint8_t</td><td>mode_blue</td><td>Current feedback mode for specified RGB device blue LED</td></tr></thead></table></div><h5><span class="headingtab">4.1.7.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_feedback_get_rgb_mode(index)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_feedback_get_rgb_mode(index))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_feedback_get_rgb_mode(index), \
        timeout)
print("kg_rsp_feedback_get_rgb_mode: { mode_red: %02X, mode_green: %02X, mode_blue: %02X" \
        " }" % (response['payload']['mode_red'], response['payload']['mode_green'], \
        response['payload']['mode_blue']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_feedback_get_rgb_mode(sender, args):
    print("kg_rsp_feedback_get_rgb_mode: { mode_red: %02X, mode_green: %02X, mode_blue:" \
            " %02X }" % (args['mode_red'], args['mode_green'], args['mode_blue']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_feedback_get_rgb_mode += my_kg_rsp_feedback_get_rgb_mode</code></pre><h4><span class="headingtab">4.1.8</span> feedback_set_rgb_mode <code style="color: #F00;">[ C0 04 03 08 ... ]</code></h4><p>Set a new RGB LED feedback mode.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x04</td><td>length</td><td>Fixed-length payload (4)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x08</td><td>id</td><td>Command ID: "set_rgb_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>index</td><td>Index of RGB device for which to set a new mode</td></tr><tr class="payload"><td>5</td><td>uint8_t</td><td>mode_red</td><td>New feedback mode to set for specified RGB device red LED</td></tr><tr class="payload"><td>6</td><td>uint8_t</td><td>mode_green</td><td>New feedback mode to set for specified RGB device green LED</td></tr><tr class="payload"><td>7</td><td>uint8_t</td><td>mode_blue</td><td>New feedback mode to set for specified RGB device blue LED</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Command class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x08</td><td>id</td><td>Command ID: "set_rgb_mode"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">4.1.8.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_feedback_set_rgb_mode(index, mode_red, mode_green, mode_blue)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_feedback_set_rgb_mode(index, mode_red, \
        mode_green, mode_blue))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_feedback_set_rgb_mode(index, \
        mode_red, mode_green, mode_blue), timeout)
print("kg_rsp_feedback_set_rgb_mode: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_feedback_set_rgb_mode(sender, args):
    print("kg_rsp_feedback_set_rgb_mode: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_feedback_set_rgb_mode += my_kg_rsp_feedback_set_rgb_mode</code></pre><h3><span class="headingtab">4.2</span> Events</h3><h4><span class="headingtab">4.2.1</span> feedback_blink_mode <code style="color: #F00;">[ 80 01 03 01 ... ]</code></h4><p>Indicates that the blink feedback mode has changed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Event class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Event ID: "blink_mode"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>mode</th><td>New blink feedback mode</td></tr></tbody></table></div><h5><span class="headingtab">4.2.1.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_feedback_blink_mode(sender, args):
    print("kg_evt_feedback_blink_mode: { mode: %02X }" % (args['mode']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_feedback_blink_mode += my_kg_evt_feedback_blink_mode</code></pre><h4><span class="headingtab">4.2.2</span> feedback_piezo_mode <code style="color: #F00;">[ 80 05 03 02 ... ]</code></h4><p>Indicates that a piezo buzzer feedback mode has changed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x05</td><td>length</td><td>Fixed-length payload (5)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Event class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Event ID: "piezo_mode"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>index</th><td>Piezo feedback device index</td></tr><tr class="payload"><td>5</td><th>uint8_t</th><th>mode</th><td>New piezo feedback mode for indicated piezo device</td></tr><tr class="payload"><td>6</td><th>uint8_t</th><th>duration</th><td>Duration to maintain tone</td></tr><tr class="payload"><td>7&nbsp;-&nbsp;8</td><th>uint16_t</th><th>frequency</th><td>Frequency of tone to generate</td></tr></tbody></table></div><h5><span class="headingtab">4.2.2.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_feedback_piezo_mode(sender, args):
    print("kg_evt_feedback_piezo_mode: { index: %02X, mode: %02X, duration: %02X," \
            " frequency: %04X }" % (args['index'], args['mode'], args['duration'],' \
            ' args['frequency']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_feedback_piezo_mode += my_kg_evt_feedback_piezo_mode</code></pre><h4><span class="headingtab">4.2.3</span> feedback_vibrate_mode <code style="color: #F00;">[ 80 03 03 03 ... ]</code></h4><p>Indicates that a vibration feedback mode has changed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x03</td><td>length</td><td>Fixed-length payload (3)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Event class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Event ID: "vibrate_mode"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>index</th><td>Vibration feedback device index</td></tr><tr class="payload"><td>5</td><th>uint8_t</th><th>mode</th><td>New vibration feedback mode for indicated vibration device</td></tr><tr class="payload"><td>6</td><th>uint8_t</th><th>duration</th><td>Duration to maintain vibration</td></tr></tbody></table></div><h5><span class="headingtab">4.2.3.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_feedback_vibrate_mode(sender, args):
    print("kg_evt_feedback_vibrate_mode: { index: %02X, mode: %02X, duration: %02X }" % \
            (args['index'], args['mode'], args['duration']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_feedback_vibrate_mode += my_kg_evt_feedback_vibrate_mode</code></pre><h4><span class="headingtab">4.2.4</span> feedback_rgb_mode <code style="color: #F00;">[ 80 04 03 04 ... ]</code></h4><p>Indicates that an RGB LED feedback mode has changed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x04</td><td>length</td><td>Fixed-length payload (4)</td></tr><tr class="header"><td>2</td><td>0x03</td><td>class</td><td>Event class: "feedback"</td></tr><tr class="header"><td>3</td><td>0x04</td><td>id</td><td>Event ID: "rgb_mode"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>index</th><td>RGB feedback device index</td></tr><tr class="payload"><td>5</td><th>uint8_t</th><th>mode_red</th><td>New feedback mode for indicated RGB device red LED</td></tr><tr class="payload"><td>6</td><th>uint8_t</th><th>mode_green</th><td>New feedback mode for indicated RGB device green LED</td></tr><tr class="payload"><td>7</td><th>uint8_t</th><th>mode_blue</th><td>New feedback mode for indicated RGB device blue LED</td></tr></tbody></table></div><h5><span class="headingtab">4.2.4.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_feedback_rgb_mode(sender, args):
    print("kg_evt_feedback_rgb_mode: { index: %02X, mode_red: %02X, mode_green: %02X," \
            " mode_blue: %02X }" % (args['index'], args['mode_red'], args['mode_green'],' \
            ' args['mode_blue']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_feedback_rgb_mode += my_kg_evt_feedback_rgb_mode</code></pre><h2><span class="headingtab">5</span> Motion class (ID = 4)</h2><p>Motion commands and events allow the control and detection of various motion sensors in the design.</p><h3><span class="headingtab">5.1</span> Commands</h3><h4><span class="headingtab">5.1.1</span> motion_get_mode <code style="color: #F00;">[ C0 01 04 01 ... ]</code></h4><p>Get current mode for specified motion sensor.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x04</td><td>class</td><td>Command class: "motion"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "get_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>index</td><td>Index of motion sensor for which to get the current mode</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x04</td><td>class</td><td>Command class: "motion"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "get_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode</td><td>Current motion sensor mode</td></tr></thead></table></div><h5><span class="headingtab">5.1.1.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_motion_get_mode(index)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_motion_get_mode(index))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_motion_get_mode(index), timeout)
print("kg_rsp_motion_get_mode: { mode: %02X }" % (response['payload']['mode']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_motion_get_mode(sender, args):
    print("kg_rsp_motion_get_mode: { mode: %02X }" % (args['mode']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_motion_get_mode += my_kg_rsp_motion_get_mode</code></pre><h4><span class="headingtab">5.1.2</span> motion_set_mode <code style="color: #F00;">[ C0 02 04 02 ... ]</code></h4><p>Set new mode for specified motion sensor.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x04</td><td>class</td><td>Command class: "motion"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "set_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>index</td><td>Index of motion sensor for which to get the current mode</td></tr><tr class="payload"><td>5</td><td>uint8_t</td><td>mode</td><td>New motion sensor mode to set</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x04</td><td>class</td><td>Command class: "motion"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "set_mode"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">5.1.2.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_motion_set_mode(index, mode)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_motion_set_mode(index, mode))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_motion_set_mode(index, mode), \
        timeout)
print("kg_rsp_motion_set_mode: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_motion_set_mode(sender, args):
    print("kg_rsp_motion_set_mode: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_motion_set_mode += my_kg_rsp_motion_set_mode</code></pre><h3><span class="headingtab">5.2</span> Events</h3><h4><span class="headingtab">5.2.1</span> motion_mode <code style="color: #F00;">[ 80 02 04 01 ... ]</code></h4><p>Indicates that a motion sensor's mode has changed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x04</td><td>class</td><td>Event class: "motion"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Event ID: "mode"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>index</th><td>Affected motion sensor</td></tr><tr class="payload"><td>5</td><th>uint8_t</th><th>mode</th><td>New motion sensor mode</td></tr></tbody></table></div><h5><span class="headingtab">5.2.1.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_motion_mode(sender, args):
    print("kg_evt_motion_mode: { index: %02X, mode: %02X }" % (args['index'], args['mode']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_motion_mode += my_kg_evt_motion_mode</code></pre><h4><span class="headingtab">5.2.2</span> motion_data <code style="color: #F00;">[ 80 03+ 04 02 ... ]</code></h4><p>Indicates that a motion sensor's measurement data has been updated.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x03+</td><td>length</td><td>Variable-length payload (3+)</td></tr><tr class="header"><td>2</td><td>0x04</td><td>class</td><td>Event class: "motion"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Event ID: "data"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>index</th><td>Relevant motion sensor</td></tr><tr class="payload"><td>5</td><th>uint8_t</th><th>flags</th><td>Flags indicating which measurement data is represented</td></tr><tr class="payload"><td>6</td><th>uint8_t[]</th><th>data</th><td>New measurement data</td></tr></tbody></table></div><h5><span class="headingtab">5.2.2.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_motion_data(sender, args):
    print("kg_evt_motion_data: { index: %02X, flags: %02X, data: %s }" % (args['index'], \
            args['flags'], ' '.join(['%02X' % b for b in args['data']])))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_motion_data += my_kg_evt_motion_data</code></pre><h4><span class="headingtab">5.2.3</span> motion_state <code style="color: #F00;">[ 80 02 04 03 ... ]</code></h4><p>Motion state change detected, such as 'still' or 'moving'.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x04</td><td>class</td><td>Event class: "motion"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Event ID: "state"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>index</th><td>Relevant motion sensor</td></tr><tr class="payload"><td>5</td><th>uint8_t</th><th>state</th><td>Type of motion state detected</td></tr></tbody></table></div><h5><span class="headingtab">5.2.3.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_motion_state(sender, args):
    print("kg_evt_motion_state: { index: %02X, state: %02X }" % (args['index'], \
            args['state']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_motion_state += my_kg_evt_motion_state</code></pre><h2><span class="headingtab">6</span> Bluetooth class (ID = 8)</h2><p>Bluetooth commands and events control and report on the wireless functionality.</p><h3><span class="headingtab">6.1</span> Commands</h3><h4><span class="headingtab">6.1.1</span> bluetooth_get_mode <code style="color: #F00;">[ C0 00 08 01 ]</code></h4><p>Get current mode for Bluetooth subsystem.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "get_mode"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x03</td><td>length</td><td>Fixed-length payload (3)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Command ID: "get_mode"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr><tr class="payload"><td>6</td><td>uint8_t</td><td>mode</td><td>Current Bluetooth mode</td></tr></thead></table></div><h5><span class="headingtab">6.1.1.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_get_mode()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_get_mode())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_get_mode(), timeout)
print("kg_rsp_bluetooth_get_mode: { result: %04X, mode: %02X }" % \
        (response['payload']['result'], response['payload']['mode']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_get_mode(sender, args):
    print("kg_rsp_bluetooth_get_mode: { result: %04X, mode: %02X }" % (args['result'], \
            args['mode']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_get_mode += my_kg_rsp_bluetooth_get_mode</code></pre><h4><span class="headingtab">6.1.2</span> bluetooth_set_mode <code style="color: #F00;">[ C0 01 08 02 ... ]</code></h4><p>Set new mode for Bluetooth subsystem.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "set_mode"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>mode</td><td>New Bluetooth mode to set</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Command ID: "set_mode"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">6.1.2.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_set_mode(mode)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_set_mode(mode))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_set_mode(mode), timeout)
print("kg_rsp_bluetooth_set_mode: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_set_mode(sender, args):
    print("kg_rsp_bluetooth_set_mode: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_set_mode += my_kg_rsp_bluetooth_set_mode</code></pre><h4><span class="headingtab">6.1.3</span> bluetooth_reset <code style="color: #F00;">[ C0 00 08 03 ]</code></h4><p>Reset Bluetooth subsystem.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Command ID: "reset"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Command ID: "reset"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">6.1.3.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_reset()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_reset())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_reset(), timeout)
print("kg_rsp_bluetooth_reset: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_reset(sender, args):
    print("kg_rsp_bluetooth_reset: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_reset += my_kg_rsp_bluetooth_reset</code></pre><h4><span class="headingtab">6.1.4</span> bluetooth_get_mac <code style="color: #F00;">[ C0 00 08 04 ]</code></h4><p>Get local Bluetooth MAC address.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x04</td><td>id</td><td>Command ID: "get_mac"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x08</td><td>length</td><td>Fixed-length payload (8)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x04</td><td>id</td><td>Command ID: "get_mac"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr><tr class="payload"><td>6&nbsp;-&nbsp;11</td><td>macaddr_t</td><td>address</td><td>Local six-byte Bluetooth MAC address</td></tr></thead></table></div><h5><span class="headingtab">6.1.4.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_get_mac()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_get_mac())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_get_mac(), timeout)
print("kg_rsp_bluetooth_get_mac: { result: %04X, address: %s }" % \
        (response['payload']['result'], ' '.join(['%02X' % b for b in' \
        ' response['payload']['address']])))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_get_mac(sender, args):
    print("kg_rsp_bluetooth_get_mac: { result: %04X, address: %s }" % (args['result'], '' \
            ' '.join(['%02X' % b for b in args['address']])))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_get_mac += my_kg_rsp_bluetooth_get_mac</code></pre><h4><span class="headingtab">6.1.5</span> bluetooth_get_pairings <code style="color: #F00;">[ C0 00 08 05 ]</code></h4><p>Get a list of all paired devices. The response will be followed by one 'bluetooth_pairing_status' event for each existing pairing entry.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x05</td><td>id</td><td>Command ID: "get_pairings"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x03</td><td>length</td><td>Fixed-length payload (3)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x05</td><td>id</td><td>Command ID: "get_pairings"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr><tr class="payload"><td>6</td><td>uint8_t</td><td>count</td><td>Number of paired devices</td></tr></thead></table></div><h5><span class="headingtab">6.1.5.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_get_pairings()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_get_pairings())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_get_pairings(), timeout)
print("kg_rsp_bluetooth_get_pairings: { result: %04X, count: %02X }" % \
        (response['payload']['result'], response['payload']['count']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_get_pairings(sender, args):
    print("kg_rsp_bluetooth_get_pairings: { result: %04X, count: %02X }" % \
            (args['result'], args['count']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_get_pairings += my_kg_rsp_bluetooth_get_pairings</code></pre><h4><span class="headingtab">6.1.6</span> bluetooth_discover <code style="color: #F00;">[ C0 01 08 06 ... ]</code></h4><p>Perform Bluetooth inquiry to locate nearby devices. The response will be followed by one 'bluetooth_inquiry_response' event for each device that is discovered during the inquiry. Once the inquiry is finished, the 'bluetooth_inquiry_complete' event will occur.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x06</td><td>id</td><td>Command ID: "discover"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>duration</td><td>Number of seconds to run discovery process</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x06</td><td>id</td><td>Command ID: "discover"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">6.1.6.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_discover(duration)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_discover(duration))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_discover(duration), \
        timeout)
print("kg_rsp_bluetooth_discover: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_discover(sender, args):
    print("kg_rsp_bluetooth_discover: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_discover += my_kg_rsp_bluetooth_discover</code></pre><h4><span class="headingtab">6.1.7</span> bluetooth_pair <code style="color: #F00;">[ C0 06 08 07 ... ]</code></h4><p>Initiate pairing request to remote device. The response will be followed by a 'bluetooth_pairing_status' event upon success, or a 'bluetooth_pairing_failed' event if unsuccessful.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x06</td><td>length</td><td>Fixed-length payload (6)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x07</td><td>id</td><td>Command ID: "pair"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;9</td><td>macaddr_t</td><td>address</td><td>Six-byte Bluetooth MAC address of remote device to pair with</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x07</td><td>id</td><td>Command ID: "pair"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">6.1.7.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_pair(address)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_pair(address))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_pair(address), timeout)
print("kg_rsp_bluetooth_pair: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_pair(sender, args):
    print("kg_rsp_bluetooth_pair: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_pair += my_kg_rsp_bluetooth_pair</code></pre><h4><span class="headingtab">6.1.8</span> bluetooth_delete_pairing <code style="color: #F00;">[ C0 01 08 08 ... ]</code></h4><p>Remove a specific pairing entry. Note that this will not actively close any Bluetooth connections to that device, if they are already open.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x08</td><td>id</td><td>Command ID: "delete_pairing"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>pairing</td><td>Index of pairing to delete</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x08</td><td>id</td><td>Command ID: "delete_pairing"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">6.1.8.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_delete_pairing(pairing)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_delete_pairing(pairing))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_delete_pairing(pairing), \
        timeout)
print("kg_rsp_bluetooth_delete_pairing: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_delete_pairing(sender, args):
    print("kg_rsp_bluetooth_delete_pairing: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_delete_pairing += my_kg_rsp_bluetooth_delete_pairing</code></pre><h4><span class="headingtab">6.1.9</span> bluetooth_clear_pairings <code style="color: #F00;">[ C0 00 08 09 ]</code></h4><p>Remove all pairing entries. Note that this will not immediately close any Bluetooth connections.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x09</td><td>id</td><td>Command ID: "clear_pairings"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x09</td><td>id</td><td>Command ID: "clear_pairings"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">6.1.9.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_clear_pairings()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_clear_pairings())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_clear_pairings(), timeout)
print("kg_rsp_bluetooth_clear_pairings: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_clear_pairings(sender, args):
    print("kg_rsp_bluetooth_clear_pairings: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_clear_pairings += my_kg_rsp_bluetooth_clear_pairings</code></pre><h4><span class="headingtab">6.1.10</span> bluetooth_get_connections <code style="color: #F00;">[ C0 00 08 0A ]</code></h4><p>Get a list of all open or pending connections. The response will be followed by one 'bluetooth_connection_status' event for each open or pending connection.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x0A</td><td>id</td><td>Command ID: "get_connections"</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x03</td><td>length</td><td>Fixed-length payload (3)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x0A</td><td>id</td><td>Command ID: "get_connections"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr><tr class="payload"><td>6</td><td>uint8_t</td><td>count</td><td>Number of open or pending connections</td></tr></thead></table></div><h5><span class="headingtab">6.1.10.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_get_connections()</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_get_connections())</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_get_connections(), \
        timeout)
print("kg_rsp_bluetooth_get_connections: { result: %04X, count: %02X }" % \
        (response['payload']['result'], response['payload']['count']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_get_connections(sender, args):
    print("kg_rsp_bluetooth_get_connections: { result: %04X, count: %02X }" % \
            (args['result'], args['count']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_get_connections += my_kg_rsp_bluetooth_get_connections</code></pre><h4><span class="headingtab">6.1.11</span> bluetooth_connect <code style="color: #F00;">[ C0 02 08 0B ... ]</code></h4><p>Attempt to open a connection to a specific paired device using a specific profile. This will be followed by a 'bluetooth_connection_status' event once the handle has been allocated.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x0B</td><td>id</td><td>Command ID: "connect"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>pairing</td><td>Index of pairing to use</td></tr><tr class="payload"><td>5</td><td>uint8_t</td><td>profile</td><td>Profile to use for connection</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x0B</td><td>id</td><td>Command ID: "connect"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">6.1.11.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_connect(pairing, profile)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_connect(pairing, profile))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_connect(pairing, \
        profile), timeout)
print("kg_rsp_bluetooth_connect: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_connect(sender, args):
    print("kg_rsp_bluetooth_connect: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_connect += my_kg_rsp_bluetooth_connect</code></pre><h4><span class="headingtab">6.1.12</span> bluetooth_disconnect <code style="color: #F00;">[ C0 01 08 0C ... ]</code></h4><p>Close a specific Bluetooth connection.</p><div class="breakauto"><table class="command"><thead><tr><th colspan="4" class="tabletitle">OUTGOING COMMAND PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Command packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x0C</td><td>id</td><td>Command ID: "disconnect"</td></tr><tr class="payload"><td>4</td><td>uint8_t</td><td>handle</td><td>Link ID of connection to close</td></tr></thead></table></div><div class="breakauto"><table class="response"><thead><tr><th colspan="4" class="tabletitle">INCOMING RESPONSE PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0xC0</td><td>type</td><td>Response packet</td></tr><tr class="header"><td>1</td><td>0x02</td><td>length</td><td>Fixed-length payload (2)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Command class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x0C</td><td>id</td><td>Command ID: "disconnect"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;5</td><td>uint16_t</td><td>result</td><td>Result code from command</td></tr></thead></table></div><h5><span class="headingtab">6.1.12.1</span> Example Usage (Python)</h5><pre><code class="python"># generate command packet only
packet = kglib.kg_cmd_bluetooth_disconnect(handle)</code></pre><pre><code class="python"># generate and send command
kglib.send_command(rxtx_obj, kglib.kg_cmd_bluetooth_disconnect(handle))</code></pre><pre><code class="python"># send command and wait for captured response
response = kglib.send_and_return(rxtx_obj, kglib.kg_cmd_bluetooth_disconnect(handle), \
        timeout)
print("kg_rsp_bluetooth_disconnect: { result: %04X }" % (response['payload']['result']))</code></pre><pre><code class="python"># create separate callback for response
def my_kg_rsp_bluetooth_disconnect(sender, args):
    print("kg_rsp_bluetooth_disconnect: { result: %04X }" % (args['result']))

# assign separate callback function to appropriate KGLib response handler collection
kglib.kg_rsp_bluetooth_disconnect += my_kg_rsp_bluetooth_disconnect</code></pre><h3><span class="headingtab">6.2</span> Events</h3><h4><span class="headingtab">6.2.1</span> bluetooth_mode <code style="color: #F00;">[ 80 01 08 01 ... ]</code></h4><p>Indicates that the Bluetooth mode has been changed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Event class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x01</td><td>id</td><td>Event ID: "mode"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>mode</th><td>New Bluetooth connectivity mode</td></tr></tbody></table></div><h5><span class="headingtab">6.2.1.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_bluetooth_mode(sender, args):
    print("kg_evt_bluetooth_mode: { mode: %02X }" % (args['mode']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_bluetooth_mode += my_kg_evt_bluetooth_mode</code></pre><h4><span class="headingtab">6.2.2</span> bluetooth_ready <code style="color: #F00;">[ 80 00 08 02 ]</code></h4><p>Indicates that the Bluetooth subsystem is ready for use.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Event class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x02</td><td>id</td><td>Event ID: "ready"</td></tr></tbody></table></div><h5><span class="headingtab">6.2.2.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_bluetooth_ready(sender, args):
    print("kg_evt_bluetooth_ready: {  }")
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_bluetooth_ready += my_kg_evt_bluetooth_ready</code></pre><h4><span class="headingtab">6.2.3</span> bluetooth_inquiry_response <code style="color: #F00;">[ 80 0D+ 08 03 ... ]</code></h4><p>Indicates that a new device has been paired.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x0D+</td><td>length</td><td>Variable-length payload (13+)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Event class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x03</td><td>id</td><td>Event ID: "inquiry_response"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;9</td><th>macaddr_t</th><th>address</th><td>Six-byte Bluetooth MAC address of remote device</td></tr><tr class="payload"><td>10&nbsp;-&nbsp;12</td><th>btcod_t</th><th>cod</th><td>Three-byte Bluetooth Class-of-Device value</td></tr><tr class="payload"><td>13</td><th>int8_t</th><th>rssi</th><td>RSSI value from discovered device</td></tr><tr class="payload"><td>14</td><th>uint8_t</th><th>status</th><td>Status within inquiry process</td></tr><tr class="payload"><td>15</td><th>uint8_t</th><th>pairing</th><td>Index of device in pairing list (0xFF if not paired)</td></tr><tr class="payload"><td>16</td><th>uint8_t[]</th><th>name</th><td>Friendly name of remote device (if available)</td></tr></tbody></table></div><h5><span class="headingtab">6.2.3.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_bluetooth_inquiry_response(sender, args):
    print("kg_evt_bluetooth_inquiry_response: { address: %s, cod: %s, rssi: %02X, status:" \
            " %02X, pairing: %02X, name: %s }" % (' '.join(['%02X' % b for b in' \
            ' args['address']]), ' '.join(['%02X' % b for b in args['cod']]),' \
            ' args['rssi'], args['status'], args['pairing'], ' '.join(['%02X' % b for b in \
            args['name']])))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_bluetooth_inquiry_response += my_kg_evt_bluetooth_inquiry_response</code></pre><h4><span class="headingtab">6.2.4</span> bluetooth_inquiry_complete <code style="color: #F00;">[ 80 01 08 04 ... ]</code></h4><p>Indicates that an ongoing Bluetooth discovery process has finished.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x01</td><td>length</td><td>Fixed-length payload (1)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Event class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x04</td><td>id</td><td>Event ID: "inquiry_complete"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>count</th><td>Total number of devices found during discovery</td></tr></tbody></table></div><h5><span class="headingtab">6.2.4.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_bluetooth_inquiry_complete(sender, args):
    print("kg_evt_bluetooth_inquiry_complete: { count: %02X }" % (args['count']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_bluetooth_inquiry_complete += my_kg_evt_bluetooth_inquiry_complete</code></pre><h4><span class="headingtab">6.2.5</span> bluetooth_pairing_status <code style="color: #F00;">[ 80 0B+ 08 05 ... ]</code></h4><p>Provides a single pairing entry detailed status record.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x0B+</td><td>length</td><td>Variable-length payload (11+)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Event class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x05</td><td>id</td><td>Event ID: "pairing_status"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>pairing</th><td>Index of device in pairing list</td></tr><tr class="payload"><td>5&nbsp;-&nbsp;10</td><th>macaddr_t</th><th>address</th><td>Six-byte Bluetooth MAC address of remote device</td></tr><tr class="payload"><td>11</td><th>uint8_t</th><th>priority</th><td>Auto-connection priority</td></tr><tr class="payload"><td>12</td><th>uint8_t</th><th>profiles_supported</th><td>Bitmask of supported profiles</td></tr><tr class="payload"><td>13</td><th>uint8_t</th><th>profiles_active</th><td>Bitmask of active profiles</td></tr><tr class="payload"><td>14</td><th>uint8_t[]</th><th>handle_list</th><td>Handles for all active Bluetooth profile connections</td></tr></tbody></table></div><h5><span class="headingtab">6.2.5.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_bluetooth_pairing_status(sender, args):
    print("kg_evt_bluetooth_pairing_status: { pairing: %02X, address: %s, priority: %02X," \
            " profiles_supported: %02X, profiles_active: %02X, handle_list: %s }" %" \
            " (args['pairing'], ' '.join(['%02X' % b for b in args['address']]),' \
            ' args['priority'], args['profiles_supported'], args['profiles_active'], ' \
            '.join(['%02X' % b for b in args['handle_list']])))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_bluetooth_pairing_status += my_kg_evt_bluetooth_pairing_status</code></pre><h4><span class="headingtab">6.2.6</span> bluetooth_pairing_failed <code style="color: #F00;">[ 80 06 08 06 ... ]</code></h4><p>Indicates that a pending pair attempt has failed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x06</td><td>length</td><td>Fixed-length payload (6)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Event class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x06</td><td>id</td><td>Event ID: "pairing_failed"</td></tr><tr class="payload"><td>4&nbsp;-&nbsp;9</td><th>macaddr_t</th><th>address</th><td>Six-byte Bluetooth MAC address which failed pairing attempt</td></tr></tbody></table></div><h5><span class="headingtab">6.2.6.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_bluetooth_pairing_failed(sender, args):
    print("kg_evt_bluetooth_pairing_failed: { address: %s }" % (' '.join(['%02X' % b for b \
            in args['address']])))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_bluetooth_pairing_failed += my_kg_evt_bluetooth_pairing_failed</code></pre><h4><span class="headingtab">6.2.7</span> bluetooth_pairings_cleared <code style="color: #F00;">[ 80 00 08 07 ]</code></h4><p>Indicates that all pairings have been removed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x00</td><td>length</td><td>No payload</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Event class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x07</td><td>id</td><td>Event ID: "pairings_cleared"</td></tr></tbody></table></div><h5><span class="headingtab">6.2.7.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_bluetooth_pairings_cleared(sender, args):
    print("kg_evt_bluetooth_pairings_cleared: {  }")
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_bluetooth_pairings_cleared += my_kg_evt_bluetooth_pairings_cleared</code></pre><h4><span class="headingtab">6.2.8</span> bluetooth_connection_status <code style="color: #F00;">[ 80 0A 08 08 ... ]</code></h4><p>Indicates that a paired device has connected.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x0A</td><td>length</td><td>Fixed-length payload (10)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Event class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x08</td><td>id</td><td>Event ID: "connection_status"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>handle</th><td>Connection handle</td></tr><tr class="payload"><td>5&nbsp;-&nbsp;10</td><th>macaddr_t</th><th>address</th><td>Six-byte Bluetooth MAC address of remote device</td></tr><tr class="payload"><td>11</td><th>uint8_t</th><th>pairing</th><td>Index of device in pairing list</td></tr><tr class="payload"><td>12</td><th>uint8_t</th><th>profile</th><td>Bluetooth profile used for this connection</td></tr><tr class="payload"><td>13</td><th>uint8_t</th><th>status</th><td>Status</td></tr></tbody></table></div><h5><span class="headingtab">6.2.8.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_bluetooth_connection_status(sender, args):
    print("kg_evt_bluetooth_connection_status: { handle: %02X, address: %s, pairing:" \
            " %02X, profile: %02X, status: %02X }" % (args['handle'], ' '.join(['%02X' %' \
            ' b for b in args['address']]), args['pairing'], args['profile'], \
            args['status']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_bluetooth_connection_status += my_kg_evt_bluetooth_connection_status</code></pre><h4><span class="headingtab">6.2.9</span> bluetooth_connection_closed <code style="color: #F00;">[ 80 03 08 09 ... ]</code></h4><p>Indicates that an active connection has been closed.</p><div class="breakauto"><table class="event"><thead><tr><th colspan="4" class="tabletitle">INCOMING EVENT PACKET STRUCTURE</th></tr><tr><th>Byte</th><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr class="header"><td>0</td><td>0x80</td><td>type</td><td>Event packet</td></tr><tr class="header"><td>1</td><td>0x03</td><td>length</td><td>Fixed-length payload (3)</td></tr><tr class="header"><td>2</td><td>0x08</td><td>class</td><td>Event class: "bluetooth"</td></tr><tr class="header"><td>3</td><td>0x09</td><td>id</td><td>Event ID: "connection_closed"</td></tr><tr class="payload"><td>4</td><th>uint8_t</th><th>handle</th><td>Connection handle</td></tr><tr class="payload"><td>5&nbsp;-&nbsp;6</td><th>uint16_t</th><th>reason</th><td>Reason for connection closure</td></tr></tbody></table></div><h5><span class="headingtab">6.2.9.1</span> Example Usage (Python)</h5><pre><code class="python"># create callback for event
def my_kg_evt_bluetooth_connection_closed(sender, args):
    print("kg_evt_bluetooth_connection_closed: { handle: %02X, reason: %04X }" % \
            (args['handle'], args['reason']))
    
# assign callback function to appropriate KGLib event handler collection
kglib.kg_evt_bluetooth_connection_closed += my_kg_evt_bluetooth_connection_closed</code></pre>

  </body>
</html>